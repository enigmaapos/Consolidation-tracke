<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Binance Futures (Perp USDT) — EMA200 Touch Scanner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Inter, Roboto, Arial; background:#0f1720; color:#e6eef8; margin:16px; }
    h1 { margin:0 0 8px 0; font-size:18px; }
    .controls { display:flex; gap:8px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
    button { padding:8px 12px; border:0; background:#0ea5a4; color:#042024; border-radius:6px; cursor:pointer; }
    button.secondary { background:#334155; color:#e6eef8; }
    input, select { padding:6px 8px; border-radius:6px; border:1px solid #334155; background:#0b1220; color:#e6eef8; }
    table { width:100%; border-collapse:collapse; margin-top:8px; }
    th, td { padding:8px 6px; font-size:13px; border-bottom:1px solid rgba(255,255,255,0.04); text-align:left; }
    th { color:#9fb3c8; font-weight:600; font-size:12px; text-transform:uppercase; }
    .green { color:#5eead4; } .red { color:#fb7185; }
    .muted { color:#94a3b8; font-size:12px; }
    .status { margin-left:8px; font-size:13px; color:#94a3b8; }
    .small { font-size:12px; color:#a7b8c8; }
    .chip { padding:4px 8px; border-radius:999px; background:#091826; border:1px solid #153241; }
  </style>
</head>
<body>
  <h1>Binance Futures (Perp USDT) — EMA200 Touch Scanner</h1>

  <div class="controls">
    <button id="startPoll">Start Live Polling</button>
    <button id="stopPoll" class="secondary" disabled>Stop Polling</button>

    <label class="chip">
      Poll interval (s):
      <input id="pollInterval" type="number" min="5" value="10" style="width:72px; margin-left:6px;">
    </label>

    <label class="chip">
      Max symbols to analyze:
      <input id="maxAnalyze" type="number" min="1" value="20" style="width:72px; margin-left:6px;">
    </label>

    <label class="chip">
      Batch size:
      <input id="batchSize" type="number" min="1" value="5" style="width:60px; margin-left:6px;">
    </label>

    <label class="chip">
      Batch delay (ms):
      <input id="batchDelay" type="number" min="300" value="1200" style="width:80px; margin-left:6px;">
    </label>

    <button id="analyze" class="secondary">Analyze EMA200 Touch</button>

    <div class="status" id="status">idle</div>
  </div>

  <div style="display:flex; gap:12px; align-items:flex-start;">
    <div style="flex:1; min-width:420px;">
      <div class="muted">Filtered pairs (24h change windows). Blacklist applied.</div>
      <table id="pairsTable">
        <thead>
          <tr>
            <th>Symbol</th>
            <th>Last</th>
            <th>24h %</th>
            <th>QuoteVol</th>
            <th>Category</th>
            <th>200EMA Touch</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div style="width:420px;">
      <div class="muted">Top EMA200 candidates</div>
      <table id="topTable">
        <thead>
          <tr><th>Symbol</th><th>EMA200-touch</th><th>Close Δ%</th></tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="muted" style="margin-top:8px; font-size:13px;">
        Tips:
        <ul style="margin:6px 0 0 18px; padding:0; font-size:12px;">
          <li>EMA200 detection fetches ~220 candles per symbol — keep maxAnalyze small to reduce requests.</li>
          <li>Tune batch size and delay if you see network or rate-limit errors.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
  // ---------- Config ----------
  const TICKER_24H = 'https://fapi.binance.com/fapi/v1/ticker/24hr';
  const KLINES = 'https://fapi.binance.com/fapi/v1/klines';
  const INTERVAL = '15m';
  const LOOKBACK_EMA200 = 220; // >=200 for EMA200
  const EMA200_TOL_PCT = 0.05; // proximity tolerance (percent)
  // 24h-change filter windows
  const MIN_POS = 0.0000001; // >0
  const MAX_POS = 15; // <=15%
  const MIN_NEG = -15; // >= -15%
  const MAX_NEG = -0.0000001; // <0
  // Blacklist
  const blacklist = [
    "ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT","AGIXUSDT","LINAUSDT",
    "LOKAUSDT","KEYUSDT","MDTUSDT","LOOMUSDT","RENUSDT","OMNIUSDT","SLERFUSDT",
    "STMXUSDT","UXLINKUSDT","BSWUSDT","NEIROETHUSDT","VIDTUSDT","TROYUSDT",
    "BAKEUSDT","AMBUSDT","MEMEFIUSDT","NULSUSDT","HIFIUSDT","LEVERUSDT","XEMUSDT",
    "STRAXUSDT","COMBOUSDT","AI16ZUSDT","MILKUSDT","TOKENUSDT","SXPUSDT","MYROUSDT","1000XUSDT","DARUSDT"
  ];

  // UI refs
  const startBtn = document.getElementById('startPoll');
  const stopBtn = document.getElementById('stopPoll');
  const pollIntervalInput = document.getElementById('pollInterval');
  const maxAnalyzeInput = document.getElementById('maxAnalyze');
  const batchSizeInput = document.getElementById('batchSize');
  const batchDelayInput = document.getElementById('batchDelay');
  const analyzeBtn = document.getElementById('analyze');
  const statusEl = document.getElementById('status');
  const pairsTbody = document.querySelector('#pairsTable tbody');
  const topTbody = document.querySelector('#topTable tbody');

  let pollTimer = null;
  let latestTickers = [];

  function setStatus(s) { statusEl.textContent = s; }

  async function safeFetch(url, params = null) {
    const p = params ? '?' + new URLSearchParams(params).toString() : '';
    const res = await fetch(url + p);
    if (!res.ok) throw new Error('HTTP ' + res.status + ' ' + res.statusText);
    return res.json();
  }

  function filterTickers(allTickers) {
    return allTickers
      .filter(t => t.symbol && t.symbol.endsWith('USDT') && !blacklist.includes(t.symbol))
      .map(t => ({
        symbol: t.symbol,
        lastPrice: Number(t.lastPrice),
        priceChangePercent: Number(t.priceChangePercent),
        quoteVolume: Number(t.quoteVolume)
      }))
      .filter(t => {
        const c = t.priceChangePercent;
        return (c > 0 && c <= MAX_POS) || (c < 0 && c >= MIN_NEG);
      })
      .sort((a,b) => Math.abs(b.priceChangePercent) - Math.abs(a.priceChangePercent));
  }

  function renderPairs(list) {
    pairsTbody.innerHTML = '';
    list.forEach(item => {
      const tr = document.createElement('tr');
      const cls = item.priceChangePercent > 0 ? 'green' : 'red';
      tr.innerHTML = `
        <td><strong>${item.symbol}</strong></td>
        <td>${item.lastPrice.toLocaleString(undefined,{maximumFractionDigits:8})}</td>
        <td class="${cls}">${item.priceChangePercent.toFixed(2)}%</td>
        <td class="small">${Number(item.quoteVolume).toLocaleString(undefined,{maximumFractionDigits:0})}</td>
        <td class="small">${item.priceChangePercent > 0 ? 'Bullish' : 'Bearish'}</td>
        <td class="small" id="ema200-${item.symbol}">—</td>
      `;
      pairsTbody.appendChild(tr);
    });
  }

  function renderTop(results) {
    topTbody.innerHTML = '';
    results.forEach(r => {
      const tr = document.createElement('tr');
      const touchCls = r.strictTouch ? 'green' : (r.closeNear ? '' : 'small');
      const touchText = r.strictTouch ? 'wick-cross' : (r.closeNear ? `close~${r.closePct.toFixed(3)}%` : 'no');
      tr.innerHTML = `
        <td><strong>${r.symbol}</strong></td>
        <td class="${touchCls}">${touchText}</td>
        <td>${r.closePct.toFixed(3)}%</td>
      `;
      topTbody.appendChild(tr);
    });
  }

  // EMA series (needed to calculate EMA200)
  function emaSeries(values, period) {
    if (values.length < period) return null;
    const k = 2 / (period + 1);
    const out = new Array(values.length).fill(null);
    let sma = values.slice(0, period).reduce((a,b)=>a+b,0)/period;
    out[period-1] = sma;
    let prev = sma;
    for (let i = period; i < values.length; i++) {
      const cur = values[i] * k + prev * (1 - k);
      out[i] = cur;
      prev = cur;
    }
    return out;
  }

  function checkEMA200Touch(klines) {
    if (!klines || klines.length < 200) return { ok: false };
    const closes = klines.map(k=>k.c);
    const highs = klines.map(k=>k.h);
    const lows  = klines.map(k=>k.l);
    const ema200Series = emaSeries(closes, 200);
    if (!ema200Series) return { ok: false };
    const ema200Latest = ema200Series[ema200Series.length - 1];
    if (!ema200Latest) return { ok: false };
    const lastH = highs[highs.length - 1];
    const lastL = lows[lows.length - 1];
    const lastC = closes[closes.length - 1];

    const strictTouch = (lastH >= ema200Latest && lastL <= ema200Latest);
    const closePct = Math.abs(lastC - ema200Latest) / ema200Latest * 100;
    const closeNear = closePct <= EMA200_TOL_PCT;

    return { ok:true, ema200: ema200Latest, strictTouch, closeNear, closePct };
  }

  async function fetchKlines(symbol, interval=INTERVAL, limit=LOOKBACK_EMA200) {
    const params = { symbol, interval, limit };
    const data = await safeFetch(KLINES, params);
    return data.map(k => ({
      t: k[0],
      o: parseFloat(k[1]),
      h: parseFloat(k[2]),
      l: parseFloat(k[3]),
      c: parseFloat(k[4]),
      v: parseFloat(k[5])
    }));
  }

  // Only fetches EMA200 candles and checks touch — batched for safety
  async function batchAnalyzeEMA200(symbols, batchSize=5, batchDelay=1200) {
    const results = [];
    for (let i=0;i<symbols.length;i+=batchSize) {
      const batch = symbols.slice(i, i+batchSize);
      setStatus(`analyzing EMA200 batch ${Math.floor(i/batchSize)+1} / ${Math.ceil(symbols.length/batchSize)}`);
      const promises = batch.map(async sym => {
        try {
          const kl = await fetchKlines(sym, INTERVAL, LOOKBACK_EMA200);
          const emaChk = checkEMA200Touch(kl);
          return { sym, emaChk };
        } catch (e) {
          return { sym, error: e.message || String(e) };
        }
      });
      const resolved = await Promise.all(promises);
      results.push(...resolved);
      if (i + batchSize < symbols.length) {
        await new Promise(r => setTimeout(r, batchDelay));
      }
    }
    setStatus('EMA200 analysis complete');
    return results;
  }

  // Poll tickers once and update UI
  async function pollTickersOnce() {
    try {
      const raw = await safeFetch(TICKER_24H);
      const filtered = filterTickers(raw);
      latestTickers = filtered;
      renderPairs(filtered.slice(0,500)); // cap UI table
      setStatus(`polled ${raw.length} tickers, ${filtered.length} matched filters`);
    } catch (e) {
      setStatus('poll error: ' + e.message);
      console.error(e);
    }
  }

  // Events
  startBtn.onclick = () => {
    const interval = Math.max(5, Number(pollIntervalInput.value) || 10);
    if (pollTimer) clearInterval(pollTimer);
    pollTickersOnce();
    pollTimer = setInterval(pollTickersOnce, interval * 1000);
    startBtn.disabled = true;
    stopBtn.disabled = false;
    setStatus('polling started');
  };

  stopBtn.onclick = () => {
    if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
    startBtn.disabled = false;
    stopBtn.disabled = true;
    setStatus('polling stopped');
  };

  analyzeBtn.onclick = async () => {
    if (!latestTickers || latestTickers.length === 0) {
      setStatus('no symbols to analyze - run poll first');
      return;
    }
    const maxAnalyze = Math.max(1, Number(maxAnalyzeInput.value) || 20);
    const batchSize = Math.max(1, Number(batchSizeInput.value) || 5);
    const batchDelay = Math.max(300, Number(batchDelayInput.value) || 1200);

    const toAnalyze = latestTickers.slice(0, maxAnalyze).map(t => t.symbol);
    setStatus(`starting EMA200 analysis for ${toAnalyze.length} symbols (batch ${batchSize}, delay ${batchDelay}ms).`);

    const results = await batchAnalyzeEMA200(toAnalyze, batchSize, batchDelay);

    const touched = [];
    results.forEach(r => {
      const idE = 'ema200-' + r.sym;
      const cellE = document.getElementById(idE);
      if (cellE) {
        if (r.emaChk && r.emaChk.ok) {
          const txt = r.emaChk.strictTouch ? 'wick-cross' : (r.emaChk.closeNear ? `close~${r.emaChk.closePct.toFixed(3)}%` : 'no');
          cellE.textContent = txt;
          if (r.emaChk.strictTouch || r.emaChk.closeNear) cellE.classList.add('green'); else cellE.classList.remove('green');
        } else {
          cellE.textContent = 'n/a';
        }
      }

      if (r.emaChk && r.emaChk.ok && (r.emaChk.strictTouch || r.emaChk.closeNear)) {
        touched.push({
          symbol: r.sym,
          strictTouch: r.emaChk.strictTouch,
          closeNear: r.emaChk.closeNear,
          closePct: r.emaChk.closePct
        });
      }
    });

    // sort: strict touch first, then nearest closePct
    touched.sort((a,b) => {
      if ((a.strictTouch?1:0) !== (b.strictTouch?1:0)) return (b.strictTouch?1:0) - (a.strictTouch?1:0);
      return a.closePct - b.closePct;
    });

    renderTop(touched.slice(0,50));
    setStatus(`EMA200 analysis finished. ${touched.length} symbols touched or near EMA200`);
  };

  setStatus('idle — click "Start Live Polling"');

  // optional auto-start
  // startBtn.click();

  </script>
</body>
</html>
