<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Binance Futures (Perp USDT) — EMA70/EMA200 Cross Scanner + Trade Setup</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Inter, Roboto, Arial; background:#0f1720; color:#e6eef8; margin:16px; }
    h1 { margin:0 0 8px 0; font-size:18px; }
    .controls { display:flex; gap:8px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
    button { padding:8px 12px; border:0; background:#0ea5a4; color:#042024; border-radius:6px; cursor:pointer; }
    button.secondary { background:#334155; color:#e6eef8; }
    input, select { padding:6px 8px; border-radius:6px; border:1px solid #334155; background:#0b1220; color:#e6eef8; }
    table { width:100%; border-collapse:collapse; margin-top:8px; }
    th, td { padding:8px 6px; font-size:12px; border-bottom:1px solid rgba(255,255,255,0.04); text-align:left; }
    th { color:#9fb3c8; font-weight:600; font-size:11px; text-transform:uppercase; }
    .green { color:#5eead4; } .red { color:#fb7185; }
    .muted { color:#94a3b8; font-size:12px; }
    .status { margin-left:8px; font-size:13px; color:#94a3b8; }
    .small { font-size:11px; color:#a7b8c8; }
    .chip { padding:4px 8px; border-radius:999px; background:#091826; border:1px solid #153241; display:flex; align-items:center; gap:6px; }
    label.chip input[type="checkbox"] { transform: translateY(1px); }
    .num { font-family: monospace; }
  </style>
</head>
<body>
  <h1>Binance Futures (Perp USDT) — EMA70/EMA200 Cross Scanner + Trade Setup</h1>

  <div class="controls">
    <button id="startPoll">Start Live Polling</button>
    <button id="stopPoll" class="secondary" disabled>Stop Polling</button>

    <label class="chip">
      Poll interval (s):
      <input id="pollInterval" type="number" min="5" value="10" style="width:72px; margin-left:6px;">
    </label>

    <label class="chip">
      Max symbols to analyze:
      <input id="maxAnalyze" type="number" min="1" value="20" style="width:72px; margin-left:6px;">
    </label>

    <label class="chip">
      Batch size:
      <input id="batchSize" type="number" min="1" value="5" style="width:60px; margin-left:6px;">
    </label>

    <label class="chip">
      Batch delay (ms):
      <input id="batchDelay" type="number" min="300" value="1200" style="width:80px; margin-left:6px;">
    </label>

    <button id="analyze" class="secondary">Analyze EMA Crosses</button>

    <label class="chip">
      <input id="autoAnalyzeToggle" type="checkbox" /> Auto-analyze on poll
    </label>

    <label class="chip">
      <input id="soundToggle" type="checkbox" /> Sound on detection
    </label>

    <label class="chip">
      Stop ATR×
      <input id="stopAtrMult" type="number" step="0.1" min="0.1" value="0.8" style="width:64px; margin-left:6px;">
    </label>

    <label class="chip">
      TP1 ATR×
      <input id="tp1AtrMult" type="number" step="0.1" min="0.1" value="1.5" style="width:64px; margin-left:6px;">
    </label>

    <label class="chip">
      TP2 ATR×
      <input id="tp2AtrMult" type="number" step="0.1" min="0.1" value="3.0" style="width:64px; margin-left:6px;">
    </label>

    <label class="chip">
      Cross window:
      <input id="crossWindow" type="number" min="1" value="3" style="width:56px; margin-left:6px;" />
    </label>

    <div class="status" id="status">idle</div>
  </div>

  <div style="display:flex; gap:12px; align-items:flex-start;">
    <div style="flex:1; min-width:540px;">
      <div class="muted">All USDT perpetual pairs (blacklist applied). Table limited to first 500 for UI responsiveness.</div>
      <table id="pairsTable">
        <thead>
          <tr>
            <th>Symbol</th>
            <th>Last</th>
            <th>24h %</th>
            <th>QuoteVol</th>
            <th>EMA Cross</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div style="width:760px;">
      <div class="muted">Top EMA cross candidates + trade setups</div>
      <table id="topTable">
        <thead>
          <tr>
            <th>Symbol</th>
            <th>Cross</th>
            <th>Dir</th>
            <th class="small">Entry</th>
            <th class="small">Stop</th>
            <th class="small">TP1</th>
            <th class="small">TP2</th>
            <th class="small">R:R1</th>
            <th class="small">R:R2</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="muted" style="margin-top:8px; font-size:12px;">
        Notes:
        <ul style="margin:6px 0 0 18px; padding:0;">
          <li>Cross detection: EMA70 crossing EMA200 inside the last <span id="cwDisplay">3</span> candles (configurable).</li>
          <li>Setups are ATR-based (14 × 15m ATR). Entry uses the last close; adjust if you prefer 'wait for retest'.</li>
          <li>Adjust multipliers / batch settings for your network and rate-limit comfort.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
  // ---------- Config ----------
  const TICKER_24H = 'https://fapi.binance.com/fapi/v1/ticker/24hr';
  const KLINES = 'https://fapi.binance.com/fapi/v1/klines';
  const INTERVAL = '15m';
  const LOOKBACK_EMA200 = 240; // we need at least 200 + some buffer; 240 is safe
  // Blacklist
  const blacklist = [
    "ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT","AGIXUSDT","LINAUSDT",
    "LOKAUSDT","KEYUSDT","MDTUSDT","LOOMUSDT","RENUSDT","OMNIUSDT","SLERFUSDT",
    "STMXUSDT","UXLINKUSDT","BSWUSDT","NEIROETHUSDT","VIDTUSDT","TROYUSDT",
    "BAKEUSDT","AMBUSDT","MEMEFIUSDT","NULSUSDT","HIFIUSDT","LEVERUSDT","XEMUSDT",
    "STRAXUSDT","COMBOUSDT","AI16ZUSDT","MILKUSDT","TOKENUSDT","SXPUSDT","MYROUSDT","1000XUSDT","DARUSDT"
  ];

  // UI refs
  const startBtn = document.getElementById('startPoll');
  const stopBtn = document.getElementById('stopPoll');
  const pollIntervalInput = document.getElementById('pollInterval');
  const maxAnalyzeInput = document.getElementById('maxAnalyze');
  const batchSizeInput = document.getElementById('batchSize');
  const batchDelayInput = document.getElementById('batchDelay');
  const analyzeBtn = document.getElementById('analyze');
  const statusEl = document.getElementById('status');
  const pairsTbody = document.querySelector('#pairsTable tbody');
  const topTbody = document.querySelector('#topTable tbody');
  const soundToggle = document.getElementById('soundToggle');
  const autoAnalyzeToggle = document.getElementById('autoAnalyzeToggle');
  const stopAtrMultInput = document.getElementById('stopAtrMult');
  const tp1AtrMultInput = document.getElementById('tp1AtrMult');
  const tp2AtrMultInput = document.getElementById('tp2AtrMult');
  const crossWindowInput = document.getElementById('crossWindow');
  const cwDisplay = document.getElementById('cwDisplay');

  cwDisplay.textContent = crossWindowInput.value;

  crossWindowInput.addEventListener('change', () => { cwDisplay.textContent = crossWindowInput.value; });

  let pollTimer = null;
  let latestTickers = [];

  function setStatus(s) { statusEl.textContent = s; }

  async function safeFetch(url, params = null) {
    const p = params ? '?' + new URLSearchParams(params).toString() : '';
    const res = await fetch(url + p);
    if (!res.ok) throw new Error('HTTP ' + res.status + ' ' + res.statusText);
    return res.json();
  }

  // FILTER: All USDT perpetual tickers except blacklist
  function filterTickers(allTickers) {
    return allTickers
      .filter(t => t.symbol && t.symbol.endsWith('USDT') && !blacklist.includes(t.symbol))
      .map(t => ({
        symbol: t.symbol,
        lastPrice: Number(t.lastPrice),
        priceChangePercent: Number(t.priceChangePercent),
        quoteVolume: Number(t.quoteVolume)
      }))
      .sort((a,b) => (b.quoteVolume || 0) - (a.quoteVolume || 0));
  }

  function renderPairs(list) {
    pairsTbody.innerHTML = '';
    list.forEach(item => {
      const tr = document.createElement('tr');
      const cls = item.priceChangePercent > 0 ? 'green' : (item.priceChangePercent < 0 ? 'red' : 'small');
      tr.innerHTML = `
        <td><strong>${item.symbol}</strong></td>
        <td class="num">${item.lastPrice.toLocaleString(undefined,{maximumFractionDigits:8})}</td>
        <td class="${cls}">${item.priceChangePercent.toFixed(2)}%</td>
        <td class="small">${Number(item.quoteVolume).toLocaleString(undefined,{maximumFractionDigits:0})}</td>
        <td class="small" id="cross-${item.symbol}">—</td>
      `;
      pairsTbody.appendChild(tr);
    });
  }

  function renderTop(results) {
    topTbody.innerHTML = '';
    results.forEach(r => {
      const tr = document.createElement('tr');
      const crossText = r.crossType === 'BULL' ? 'EMA70>EMA200 (bull)' : 'EMA70<EMA200 (bear)';
      const crossCls = r.crossType === 'BULL' ? 'green' : 'red';
      const dirCls = r.direction === 'LONG' ? 'green' : 'red';
      tr.innerHTML = `
        <td><strong>${r.symbol}</strong></td>
        <td class="${crossCls}">${crossText}</td>
        <td class="${dirCls}">${r.direction}</td>
        <td class="num">${r.entry.toFixed(r.prec)}</td>
        <td class="num">${r.stop.toFixed(r.prec)}</td>
        <td class="num">${r.tp1.toFixed(r.prec)}</td>
        <td class="num">${r.tp2.toFixed(r.prec)}</td>
        <td class="num">${r.rr1.toFixed(2)}</td>
        <td class="num">${r.rr2.toFixed(2)}</td>
      `;
      topTbody.appendChild(tr);
    });
  }

  // EMA series
  function emaSeries(values, period) {
    if (values.length < period) return null;
    const k = 2 / (period + 1);
    const out = new Array(values.length).fill(null);
    let sma = values.slice(0, period).reduce((a,b)=>a+b,0)/period;
    out[period-1] = sma;
    let prev = sma;
    for (let i = period; i < values.length; i++) {
      const cur = values[i] * k + prev * (1 - k);
      out[i] = cur;
      prev = cur;
    }
    return out;
  }

  // ATR computation
  function computeATR(klines, period = 14) {
    if (!klines || klines.length < period + 1) return null;
    const trs = [];
    for (let i = 1; i < klines.length; i++) {
      const hi = klines[i].h;
      const lo = klines[i].l;
      const prevC = klines[i-1].c;
      const tr = Math.max(hi - lo, Math.abs(hi - prevC), Math.abs(lo - prevC));
      trs.push(tr);
    }
    const slice = trs.slice(-period);
    const atr = slice.reduce((a,b)=>a+b,0)/slice.length;
    return atr;
  }

  // Detect recent EMA70/EMA200 cross within crossWindow candles (default 3)
  function checkEMACross(klines, crossWindow = 3) {
    if (!klines || klines.length < 210) return { ok:false };
    const closes = klines.map(k=>k.c);
    const ema70 = emaSeries(closes, 70);
    const ema200 = emaSeries(closes, 200);
    if (!ema70 || !ema200) return { ok:false };

    // We'll check the sign of (ema70 - ema200) for the last crossWindow+1 points
    const diff = [];
    const n = ema70.length;
    for (let i = n - (crossWindow + 1); i < n; i++) {
      if (i >= 0) diff.push(ema70[i] - ema200[i]);
    }
    if (diff.length < 2) return { ok:false };

    // Look for a sign change in diff: negative->positive = bullish, positive->negative = bearish
    let crossType = null;
    let crossIndexFromEnd = null; // 0 => latest candle, 1 => previous, etc.
    for (let j = 1; j < diff.length; j++) {
      const prev = diff[j-1];
      const cur = diff[j];
      if (prev <= 0 && cur > 0) {
        crossType = 'BULL'; // ema70 crossed above ema200
        crossIndexFromEnd = diff.length - 1 - j;
        break;
      }
      if (prev >= 0 && cur < 0) {
        crossType = 'BEAR';
        crossIndexFromEnd = diff.length - 1 - j;
        break;
      }
    }

    // also capture latest price info
    const lastIdx = closes.length - 1;
    const lastClose = closes[lastIdx];
    const lastHigh = klines[lastIdx].h;
    const lastLow = klines[lastIdx].l;

    return {
      ok: true,
      ema70Series: ema70,
      ema200Series: ema200,
      crossType, // 'BULL' | 'BEAR' | null
      crossIndexFromEnd,
      lastClose,
      lastHigh,
      lastLow,
      closes,
      highs: klines.map(k=>k.h),
      lows: klines.map(k=>k.l)
    };
  }

  async function fetchKlines(symbol, interval=INTERVAL, limit=LOOKBACK_EMA200) {
    const params = { symbol, interval, limit };
    const data = await safeFetch(KLINES, params);
    return data.map(k => ({
      t: k[0],
      o: parseFloat(k[1]),
      h: parseFloat(k[2]),
      l: parseFloat(k[3]),
      c: parseFloat(k[4]),
      v: parseFloat(k[5])
    }));
  }

  // Batch analyze: fetch klines and run cross detection
  async function batchAnalyzeCross(symbols, batchSize=5, batchDelay=1200) {
    const results = [];
    const crossWindow = Math.max(1, Number(crossWindowInput.value) || 3);
    for (let i=0;i<symbols.length;i+=batchSize) {
      const batch = symbols.slice(i, i+batchSize);
      setStatus(`analyzing cross batch ${Math.floor(i/batchSize)+1} / ${Math.ceil(symbols.length/batchSize)}`);
      const promises = batch.map(async sym => {
        try {
          const kl = await fetchKlines(sym, INTERVAL, LOOKBACK_EMA200);
          const chk = checkEMACross(kl, crossWindow);
          return { sym, chk, kl };
        } catch (e) {
          return { sym, error: e.message || String(e) };
        }
      });
      const resolved = await Promise.all(promises);
      results.push(...resolved);
      if (i + batchSize < symbols.length) {
        await new Promise(r => setTimeout(r, batchDelay));
      }
    }
    setStatus('EMA cross analysis complete');
    return results;
  }

  // --- Audio helpers (Web Audio API) ---
  let audioCtx = null;
  let audioUnlocked = false;
  function ensureAudioContext() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().then(() => { audioUnlocked = true; }).catch(()=>{ audioUnlocked = false; });
    } else {
      audioUnlocked = true;
    }
  }
  function playBeep(freq=880, duration=120, volume=0.12, type='sine') {
    if (!audioCtx) try { ensureAudioContext(); } catch(e){ return; }
    if (!audioUnlocked) return;
    try {
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, now);
      g.gain.setValueAtTime(volume, now);
      g.gain.linearRampToValueAtTime(volume, now + 0.01);
      g.gain.linearRampToValueAtTime(0.0001, now + duration/1000);
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start(now);
      o.stop(now + duration/1000 + 0.02);
    } catch (e) { /* silent fail */ }
  }
  function playNotification() {
    if (!soundToggle.checked) return;
    playBeep(1046, 80, 0.08);
    setTimeout(()=>playBeep(1318, 70, 0.07), 120);
    setTimeout(()=>playBeep(1568, 60, 0.06), 220);
  }

  // Trade setup builder using ATR, direction from cross
  function buildTradeSetupByCross(sym, chk, klines) {
    if (!chk || !chk.ok || !chk.crossType) return null;
    const atr = computeATR(klines.slice(-40), 14) || computeATR(klines, 14) || 0;
    const stopAtrMult = Math.max(0.1, Number(stopAtrMultInput.value) || 0.8);
    const tp1AtrMult = Math.max(0.1, Number(tp1AtrMultInput.value) || 1.5);
    const tp2AtrMult = Math.max(0.1, Number(tp2AtrMultInput.value) || 3.0);

    const lastClose = chk.lastClose;
    const lastLow = chk.lastLow;
    const lastHigh = chk.lastHigh;

    // precision
    let prec = 4;
    if (lastClose >= 100) prec = 2;
    else if (lastClose >= 10) prec = 3;
    else if (lastClose < 1) prec = 6;

    // direction from cross
    const direction = chk.crossType === 'BULL' ? 'LONG' : 'SHORT';
    const entry = lastClose;

    let stop;
    if (direction === 'LONG') {
      // place stop below recent low and below EMA200 (safe)
      const ema200Latest = chk.ema200Series ? chk.ema200Series[chk.ema200Series.length -1] : null;
      stop = Math.min(lastLow - atr * stopAtrMult, (ema200Latest ? ema200Latest - atr * 0.25 : lastLow - atr*stopAtrMult));
      if (stop >= entry) stop = entry - Math.max(atr * 0.2, (entry * 0.0005));
    } else {
      const ema200Latest = chk.ema200Series ? chk.ema200Series[chk.ema200Series.length -1] : null;
      stop = Math.max(lastHigh + atr * stopAtrMult, (ema200Latest ? ema200Latest + atr * 0.25 : lastHigh + atr*stopAtrMult));
      if (stop <= entry) stop = entry + Math.max(atr * 0.2, (entry * 0.0005));
    }

    let tp1, tp2;
    if (direction === 'LONG') {
      tp1 = entry + atr * tp1AtrMult;
      tp2 = entry + atr * tp2AtrMult;
    } else {
      tp1 = entry - atr * tp1AtrMult;
      tp2 = entry - atr * tp2AtrMult;
    }

    const risk = Math.abs(entry - stop);
    const rr1 = risk > 0 ? Math.abs(tp1 - entry) / risk : 0;
    const rr2 = risk > 0 ? Math.abs(tp2 - entry) / risk : 0;

    return {
      symbol: sym,
      direction,
      entry,
      stop,
      tp1,
      tp2,
      rr1,
      rr2,
      atr,
      prec
    };
  }

  // Handle results: mark pairs table, build setups, play sounds
  async function handleCrossResultsAndPlaySound(results) {
    const detected = [];
    results.forEach(r => {
      const id = 'cross-' + r.sym;
      const cell = document.getElementById(id);
      if (cell) {
        if (r.chk && r.chk.ok && r.chk.crossType) {
          const txt = r.chk.crossType === 'BULL' ? '70→200 (bull)' : '70→200 (bear)';
          cell.textContent = txt;
          cell.classList.remove('green','red');
          cell.classList.add(r.chk.crossType === 'BULL' ? 'green' : 'red');
        } else {
          cell.textContent = '—';
          cell.classList.remove('green','red');
        }
      }

      if (r.chk && r.chk.ok && r.chk.crossType) {
        const setup = buildTradeSetupByCross(r.sym, r.chk, r.kl || []);
        if (setup) {
          detected.push({
            symbol: r.sym,
            crossType: r.chk.crossType,
            crossIndexFromEnd: r.chk.crossIndexFromEnd,
            closePct: Math.abs(r.chk.lastClose - (r.chk.ema200Series ? r.chk.ema200Series[r.chk.ema200Series.length-1] : r.chk.lastClose))/ (r.chk.ema200Series ? r.chk.ema200Series[r.chk.ema200Series.length-1] : r.chk.lastClose) * 100,
            ...setup
          });
        }
      }
    });

    if (soundToggle.checked && detected.length > 0) {
      playNotification();
      let delay = 360;
      detected.slice(0,10).forEach(d => {
        setTimeout(() => {
          if (d.crossType === 'BULL') playBeep(1400, 90, 0.09);
          else playBeep(900, 120, 0.11);
        }, delay);
        delay += 140;
      });
    }

    // sort: bull first (you can change sorting preferences)
    detected.sort((a,b) => {
      if (a.crossType !== b.crossType) return a.crossType === 'BULL' ? -1 : 1;
      if (b.rr1 !== a.rr1) return b.rr1 - a.rr1;
      return a.closePct - b.closePct;
    });

    renderTop(detected.slice(0,50));
    setStatus(`EMA cross analysis finished. ${detected.length} symbols with cross setups`);
  }

  // Poll tickers and optionally auto-analyze
  async function pollTickersOnce() {
    try {
      const raw = await safeFetch(TICKER_24H);
      const filtered = filterTickers(raw);
      latestTickers = filtered;
      renderPairs(filtered.slice(0,500));
      setStatus(`polled ${raw.length} tickers, ${filtered.length} USDT perpetuals (blacklist removed)`);

      if (autoAnalyzeToggle.checked) {
        ensureAudioContext();
        const maxAnalyze = Math.max(1, Number(maxAnalyzeInput.value) || 20);
        const batchSize = Math.max(1, Number(batchSizeInput.value) || 5);
        const batchDelay = Math.max(300, Number(batchDelayInput.value) || 1200);
        const toAnalyze = latestTickers.slice(0, maxAnalyze).map(t => t.symbol);
        setStatus(`(auto) starting EMA cross analysis for ${toAnalyze.length} symbols...`);
        const results = await batchAnalyzeCross(toAnalyze, batchSize, batchDelay);
        await handleCrossResultsAndPlaySound(results);
      }
    } catch (e) {
      setStatus('poll error: ' + e.message);
      console.error(e);
    }
  }

  // Events
  startBtn.onclick = () => {
    const interval = Math.max(5, Number(pollIntervalInput.value) || 10);
    if (pollTimer) clearInterval(pollTimer);
    ensureAudioContext();
    pollTickersOnce();
    pollTimer = setInterval(pollTickersOnce, interval * 1000);
    startBtn.disabled = true;
    stopBtn.disabled = false;
    setStatus('polling started');
  };

  stopBtn.onclick = () => {
    if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
    startBtn.disabled = false;
    stopBtn.disabled = true;
    setStatus('polling stopped');
  };

  analyzeBtn.onclick = async () => {
    if (!latestTickers || latestTickers.length === 0) {
      setStatus('no symbols to analyze - run poll first');
      return;
    }
    ensureAudioContext();
    const maxAnalyze = Math.max(1, Number(maxAnalyzeInput.value) || 20);
    const batchSize = Math.max(1, Number(batchSizeInput.value) || 5);
    const batchDelay = Math.max(300, Number(batchDelayInput.value) || 1200);
    const toAnalyze = latestTickers.slice(0, maxAnalyze).map(t => t.symbol);
    setStatus(`starting EMA cross analysis for ${toAnalyze.length} symbols (batch ${batchSize}, delay ${batchDelay}ms).`);
    const results = await batchAnalyzeCross(toAnalyze, batchSize, batchDelay);
    await handleCrossResultsAndPlaySound(results);
  };

  setStatus('idle — click "Start Live Polling"');

  // optional auto-start
  // startBtn.click();
  </script>
</body>
</html>
