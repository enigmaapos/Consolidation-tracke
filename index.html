<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Binance Futures ‚Äî EMA70/EMA200 Cross Scanner + Leverage Calculator</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0f1720;
      --card:#0b1220;
      --muted:#94a3b8;
      --accent:#0ea5a4;
      --accent-2:#06b6d4;
      --glass-border: rgba(255,255,255,0.04);
      --green:#5eead4;
      --red:#fb7185;
      --radius:12px;
      --pad:12px;
      --shadow: 0 6px 18px rgba(2,6,23,0.6);
      --max-card-height: 60vh;
    }
    html,body{height:100%;margin:0;font-family:Inter, Roboto, Arial, system-ui,-apple-system; background:var(--bg); color:#e6eef8; -webkit-font-smoothing:antialiased;}
    h1{margin:0 0 6px 0;font-size:18px;font-weight:600}
    .muted{color:var(--muted); font-size:13px}
    .wrap{padding:16px; max-width:1400px; margin:0 auto; box-sizing:border-box;}
    .topbar{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:12px;}
    .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; width:100%;}
    .left { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .right { margin-left:auto; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button{ padding:10px 14px; border:0; background:var(--accent); color:var(--bg); border-radius:10px; cursor:pointer; font-weight:700; box-shadow:0 2px 6px rgba(0,0,0,0.4); }
    button.secondary{ background:#334155; color:var(--muted); }
    button.warn{ background:#ef4444; color:white; }
    input, select{ padding:8px 10px; border-radius:8px; border:1px solid #334155; background:var(--card); color:inherit; min-height:36px; box-sizing:border-box; }
    .chip{ padding:6px 10px; border-radius:999px; background:rgba(9,24,38,0.45); border:1px solid rgba(21,50,65,0.6); display:flex; align-items:center; gap:8px; color:var(--muted); font-size:13px; }
    .grid{ display:grid; grid-template-columns: 1fr 760px; gap:12px; align-items:start; }
    @media (max-width:1100px){ .grid{ grid-template-columns: 1fr 420px; } }
    @media (max-width:900px){ .grid{ grid-template-columns: 1fr; } }
    .card{ background:var(--card); border-radius:var(--radius); padding:12px; box-shadow:var(--shadow); border:1px solid var(--glass-border); box-sizing:border-box; }
    .card h2{ margin:0 0 8px 0; font-size:14px; color:var(--muted); font-weight:600 }
    table{ width:100%; border-collapse:collapse; font-size:13px; }
    th, td{ padding:8px 6px; border-bottom:1px solid rgba(255,255,255,0.03); text-align:left; vertical-align:middle; }
    th{ color:#9fb3c8; font-weight:700; font-size:12px; text-transform:uppercase; letter-spacing:0.03em; position:sticky; top:0; background:linear-gradient(180deg, rgba(11,18,32,0.75), rgba(11,18,32,0.85)); z-index:2;}
    tbody tr:hover{ background:rgba(255,255,255,0.02); }
    tbody tr:nth-child(odd) td{ background: transparent; }
    .green{ color:var(--green); }
    .red{ color:var(--red); }
    .small{ color:var(--muted); font-size:12px; }
    .num{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; }
    .table-wrap{ max-height:var(--max-card-height); overflow:auto; padding-top:6px; -webkit-overflow-scrolling:touch; }
    .wide { max-width:100%; }
    .status{ margin-left:8px; font-size:13px; color:var(--muted); display:flex; align-items:center; gap:8px; }
    .status .dot{ width:10px; height:10px; border-radius:50%; background:transparent; display:inline-block; }
    .status .dot.running{ background:var(--green); box-shadow:0 0 8px rgba(94,234,212,0.12); }
    .status .dot.idle{ background:#334155; }
    .controls .spacer{ flex:1; }
    .legend{ display:flex; gap:8px; align-items:center; margin-top:8px; color:var(--muted); font-size:12px; flex-wrap:wrap; }
    .badge{ padding:4px 8px; border-radius:999px; background:rgba(255,255,255,0.03); color:var(--muted); font-size:12px; }
    .link{ color:var(--accent-2); text-decoration:none; font-weight:600; }
    .input-inline{ display:inline-flex; align-items:center; gap:6px; }
    .spinner{ width:18px;height:18px;border-radius:50%;border:2px solid rgba(255,255,255,0.06);border-top-color:var(--accent);animation:spin .9s linear infinite; display:inline-block; }
    @keyframes spin{to{transform:rotate(360deg)}}
    .help{ font-size:12px;color:var(--muted); margin-top:8px; }

    /* Leverage calculator specific */
    .calc-input { width:110px; padding:8px; border-radius:8px; background: #0b1220; border:1px solid #334155; color: #e6eef8; text-align:right; }
    .calc-list { margin-top:8px; display:flex; flex-direction:column; gap:8px; }
    .calc-item { display:flex; justify-content:space-between; gap:12px; border-radius:8px; padding:8px; border:1px solid rgba(255,255,255,0.03); }
    .calc-item .danger { color: #ff9b9b; font-weight:700; }
    .calc-add { display:flex; gap:8px; align-items:center; margin-top:8px; }

    @media (max-width:600px){
      .grid{ grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Binance Futures ‚Äî EMA70/EMA200 Cross Scanner + Leverage Calculator</h1>

    <div class="topbar">
      <div class="controls">
        <div class="left">
          <button id="startPoll" title="Start polling tickers">Start</button>
          <button id="pausePoll" class="secondary" disabled title="Pause polling (keeps last results)">Pause</button>
          <button id="refreshOnce" class="secondary" title="Fetch tickers once">Refresh</button>

          <label class="chip input-inline" title="How often to poll (seconds)">
            Poll (s):
            <input id="pollInterval" type="number" min="5" value="10" style="width:76px;">
          </label>

          <label class="chip input-inline" title="Max symbols considered for EMA analysis">
            Max symbols:
            <input id="maxAnalyze" type="number" min="1" value="20" style="width:76px;">
          </label>

          <label class="chip input-inline" title="Analyze batch size">
            Batch:
            <input id="batchSize" type="number" min="1" value="5" style="width:64px;">
          </label>

          <label class="chip input-inline" title="Delay (ms) between each batch to avoid rate limits">
            Delay (ms):
            <input id="batchDelay" type="number" min="300" value="1200" style="width:80px;">
          </label>

          <button id="analyze" class="secondary" title="Run EMA cross analysis now">Analyze</button>
        </div>

        <div class="right" style="align-items:center;">
          <label class="chip" title="Automatically run EMA analysis after polling">
            <input id="autoAnalyzeToggle" type="checkbox" /> Auto
          </label>

          <label class="chip" title="Enable sound alerts">
            <input id="soundToggle" type="checkbox" /> Sound
          </label>

          <div class="status" id="status" aria-live="polite">
            <span class="dot idle" id="statusDot"></span>
            <span id="statusText">idle ‚Äî not polling</span>
            <span class="muted" id="lastUpdated" style="margin-left:8px;"></span>
          </div>
        </div>
      </div>
    </div>

    <div style="display:flex;gap:12px;align-items:center;margin-bottom:10px;">
      <div style="flex:1;">
        <input id="searchBox" placeholder="Search symbol (e.g. BTCUSDT) or filter by text..." style="width:100%; padding:10px 12px; border-radius:10px; border:1px solid #334155; background:var(--card); color:inherit;">
      </div>

      <div style="display:flex;gap:8px;align-items:center;">
        <select id="crossFilter" style="min-width:120px; padding:8px; border-radius:8px; background:var(--card); color:inherit;">
          <option value="ALL">All crosses & symbols</option>
          <option value="BULL">Bull crosses only</option>
          <option value="BEAR">Bear crosses only</option>
          <option value="NO_CROSS">No cross</option>
        </select>

        <select id="sortBy" style="min-width:160px; padding:8px; border-radius:8px; background:var(--card); color:inherit;">
          <option value="volume_desc">Sort: QuoteVol (desc)</option>
          <option value="volume_asc">Sort: QuoteVol (asc)</option>
          <option value="change_desc">Sort: 24h % (desc)</option>
          <option value="change_asc">Sort: 24h % (asc)</option>
          <option value="symbol_asc">Sort: Symbol (A ‚Üí Z)</option>
        </select>
      </div>
    </div>

    <div class="grid" id="grid">
      <!-- Left: all pairs -->
      <div class="card">
        <h2>All USDT perpetual pairs <span class="muted" style="font-weight:500"> (first 500 shown)</span></h2>
        <div class="muted">Use search / filter / sort to find symbols quickly.</div>

        <div class="table-wrap card-body">
          <table id="pairsTable" role="table" aria-label="Filtered pairs">
            <thead>
              <tr>
                <th data-col="symbol">Symbol</th>
                <th data-col="last">Last</th>
                <th data-col="change">24h %</th>
                <th data-col="vol">QuoteVol</th>
                <th data-col="cross">EMA Cross</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div class="legend" style="margin-top:8px;">
          <div class="badge"><span class="green">‚óè</span> Bull cross</div>
          <div class="badge"><span class="red">‚óè</span> Bear cross</div>
          <div class="badge">Click a symbol's chart link to open TradingView</div>
        </div>
      </div>

      <!-- Right column: Leverage calculator + Top candidates -->
      <div style="display:flex;flex-direction:column;gap:12px;">
        <!-- Leverage Calculator Card -->
        <div class="card" id="calcCard">
          <h2>üìà Leverage Profit & Loss Calculator</h2>
          <div class="muted">Quick calculator for position P/L and liquidation warning.</div>

          <div style="display:flex;flex-direction:column;gap:10px;margin-top:10px;">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <label class="muted">ü™ô Capital (margin)</label>
              <input id="calcCapital" class="calc-input" type="number" min="0" value="10" />
            </div>

            <div style="display:flex;justify-content:space-between;align-items:center;">
              <label class="muted">üìä Leverage</label>
              <input id="calcLeverage" class="calc-input" type="number" min="1" value="20" />
            </div>

            <div class="calc-add">
              <input id="calcInputPercent" type="number" placeholder="Add % move" class="calc-input" style="width:120px;" />
              <button id="calcAddBtn" class="secondary" style="padding:8px 10px;">‚ûï Add</button>
              <div style="flex:1"></div>
            </div>

            <div class="calc-list" id="calcList"></div>

            <div class="muted" style="font-size:12px;margin-top:6px;">
              ‚ö†Ô∏è Approx. liquidation threshold: <span id="liqText" style="color:#ffd36b;font-weight:700;">0.00%</span> loss at <span id="liqLeverage">20x</span>.
            </div>
          </div>
        </div>

        <!-- Top EMA cross candidates -->
        <div class="card wide">
          <h2>Top EMA cross candidates + trade setups</h2>
          <div class="muted">Setups are ATR-based (14 √ó 15m ATR). Entry uses last close.</div>

          <div class="table-wrap card-body" style="padding-top:6px;">
            <table id="topTable" role="table" aria-label="Top EMA candidates">
              <thead>
                <tr>
                  <th>Symbol</th>
                  <th>Cross</th>
                  <th>24h %</th>
                  <th>Dir</th>
                  <th class="small">Entry</th>
                  <th class="small">Stop</th>
                  <th class="small">TP1</th>
                  <th class="small">TP2</th>
                  <th class="small">R:R1</th>
                  <th class="small">R:R2</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <div class="help">
            Tips:
            <ul style="margin:6px 0 0 18px; padding:0;">
              <li>Click Start or Analyze once to unlock audio (required by browsers).</li>
              <li>Enable Auto-analyze carefully ‚Äî it fetches many klines (keep Max symbols low).</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Guard: only run in the real browser (prevents SSR/build errors)
    if (typeof window !== 'undefined' && typeof document !== 'undefined') {
      window.addEventListener('DOMContentLoaded', function () {
        /* ============================
           Full scanner + calculator
           (exact same logic as before)
           ============================ */

        // --- CONFIG & ENDPOINTS ---
        const TICKER_24H = 'https://fapi.binance.com/fapi/v1/ticker/24hr';
        const KLINES = 'https://fapi.binance.com/fapi/v1/klines';
        const INTERVAL = '15m';
        const LOOKBACK_EMA200 = 240;

        // blacklist
        const blacklist = ["ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT","AGIXUSDT","LINAUSDT","LOKAUSDT","KEYUSDT","MDTUSDT","LOOMUSDT","RENUSDT","OMNIUSDT","SLERFUSDT","STMXUSDT","UXLINKUSDT","BSWUSDT","NEIROETHUSDT","VIDTUSDT","TROYUSDT","BAKEUSDT","AMBUSDT","MEMEFIUSDT","NULSUSDT","HIFIUSDT","LEVERUSDT","XEMUSDT","STRAXUSDT","COMBOUSDT","AI16ZUSDT","MILKUSDT","TOKENUSDT","SXPUSDT","MYROUSDT","1000XUSDT","DARUSDT"];

        // --- UI refs ---
        const startBtn = document.getElementById('startPoll');
        const pauseBtn = document.getElementById('pausePoll');
        const refreshBtn = document.getElementById('refreshOnce');
        const analyzeBtn = document.getElementById('analyze');
        const pollIntervalInput = document.getElementById('pollInterval');
        const maxAnalyzeInput = document.getElementById('maxAnalyze');
        const batchSizeInput = document.getElementById('batchSize');
        const batchDelayInput = document.getElementById('batchDelay');
        const autoAnalyzeToggle = document.getElementById('autoAnalyzeToggle');
        const soundToggle = document.getElementById('soundToggle');
        const searchBox = document.getElementById('searchBox');
        const crossFilter = document.getElementById('crossFilter');
        const sortBy = document.getElementById('sortBy');
        const statusText = document.getElementById('statusText');
        const statusDot = document.getElementById('statusDot');
        const lastUpdatedEl = document.getElementById('lastUpdated');
        const pairsTbody = document.querySelector('#pairsTable tbody');
        const topTbody = document.querySelector('#topTable tbody');

        // calculator refs
        const capitalInput = document.getElementById('calcCapital');
        const leverageInput = document.getElementById('calcLeverage');
        const percentInput = document.getElementById('calcInputPercent');
        const addBtn = document.getElementById('calcAddBtn');
        const listEl = document.getElementById('calcList');
        const liqText = document.getElementById('liqText');
        const liqLeverage = document.getElementById('liqLeverage');

        // --- state ---
        let pollTimer = null;
        let latestTickers = [];
        let lastResults = [];
        let isPaused = false;
        let audioCtx = null, audioUnlocked = false;

        // --- util helpers ---
        function setStatus(text, running=false){
          statusText.textContent = text;
          if(running){ statusDot.classList.remove('idle'); statusDot.classList.add('running'); }
          else { statusDot.classList.remove('running'); statusDot.classList.add('idle'); }
        }
        function setLastUpdated(ts = Date.now()){ lastUpdatedEl.textContent = new Date(ts).toLocaleString(); }

        function safeFetch(url, params=null, timeout=15000){
          const p = params ? '?' + new URLSearchParams(params).toString() : '';
          const controller = new AbortController();
          const id = setTimeout(()=>controller.abort(), timeout);
          return fetch(url + p, { signal: controller.signal })
            .then(res=>{ clearTimeout(id); if(!res.ok) throw new Error('HTTP ' + res.status); return res.json(); })
            .catch(err => { clearTimeout(id); throw err; });
        }

        function filterTickers(all){
          return all.filter(t => t.symbol && t.symbol.endsWith('USDT') && !blacklist.includes(t.symbol))
            .map(t => ({ symbol: t.symbol, lastPrice: Number(t.lastPrice), priceChangePercent: Number(t.priceChangePercent), quoteVolume: Number(t.quoteVolume) }));
        }

        function renderPairs(list){
          pairsTbody.innerHTML = '';
          list.forEach(item=>{
            const tr = document.createElement('tr');
            const cls = item.priceChangePercent > 0 ? 'green' : (item.priceChangePercent < 0 ? 'red' : 'small');
            tr.innerHTML = `
              <td><strong>${item.symbol}</strong></td>
              <td class="num">${item.lastPrice.toLocaleString(undefined,{maximumFractionDigits:8})}</td>
              <td class="${cls}">${item.priceChangePercent.toFixed(2)}%</td>
              <td class="small">${Number(item.quoteVolume).toLocaleString(undefined,{maximumFractionDigits:0})}</td>
              <td class="small" id="cross-${item.symbol}">‚Äî</td>
            `;
            pairsTbody.appendChild(tr);
          });
        }

        function renderTop(results){
          topTbody.innerHTML = '';
          (results || []).forEach(r=>{
            const tr = document.createElement('tr');
            const crossText = r.crossType === 'BULL' ? 'EMA70>EMA200 (bull)' : 'EMA70<EMA200 (bear)';
            const crossCls = r.crossType === 'BULL' ? 'green' : 'red';
            const dirCls = r.direction === 'LONG' ? 'green' : 'red';
            tr.innerHTML = `
              <td><strong>${r.symbol}</strong></td>
              <td class="${crossCls}">${crossText}</td>
              <td class="num ${r.priceChangePercent >= 0 ? 'green' : 'red'}">${(r.priceChangePercent||0).toFixed(2)}%</td>
              <td class="${dirCls}">${r.direction}</td>
              <td class="num">${r.entry.toFixed(r.prec)}</td>
              <td class="num">${r.stop.toFixed(r.prec)}</td>
              <td class="num">${r.tp1.toFixed(r.prec)}</td>
              <td class="num">${r.tp2.toFixed(r.prec)}</td>
              <td class="num">${r.rr1.toFixed(2)}</td>
              <td class="num">${r.rr2.toFixed(2)}</td>
            `;
            topTbody.appendChild(tr);
          });
        }

        /* EMA / ATR / Cross detection (same reliable logic) */
        function emaSeries(values, period){
          if (values.length < period) return null;
          const k = 2 / (period + 1);
          const out = new Array(values.length).fill(null);
          let sma = values.slice(0, period).reduce((a,b)=>a+b,0)/period;
          out[period-1] = sma;
          let prev = sma;
          for (let i = period; i < values.length; i++) {
            const cur = values[i] * k + prev * (1 - k);
            out[i] = cur;
            prev = cur;
          }
          return out;
        }

        function computeATR(klines, period = 14){
          if (!klines || klines.length < period + 1) return null;
          const trs = [];
          for (let i = 1; i < klines.length; i++) {
            const hi = klines[i].h, lo = klines[i].l, prevC = klines[i-1].c;
            const tr = Math.max(hi - lo, Math.abs(hi - prevC), Math.abs(lo - prevC));
            trs.push(tr);
          }
          const slice = trs.slice(-period);
          return slice.reduce((a,b)=>a+b,0)/slice.length;
        }

        // returns { ok:true, crossType: 'BULL'|'BEAR'|null, crossIndexFromEnd, ... }
        function checkEMACross(klines, crossWindow = 3) {
          if (!klines || klines.length < 210) return { ok:false };
          const closes = klines.map(k=>k.c);
          const ema70 = emaSeries(closes, 70);
          const ema200 = emaSeries(closes, 200);
          if (!ema70 || !ema200) return { ok:false };

          // compute diff for last (crossWindow + 1) points
          const diff = [];
          const n = ema70.length;
          for (let i = n - (crossWindow + 1); i < n; i++) {
            if (i >= 0) diff.push(ema70[i] - ema200[i]);
          }
          if (diff.length < 2) return { ok:false };

          let crossType = null, crossIndexFromEnd = null;
          for (let j = 1; j < diff.length; j++) {
            const prev = diff[j-1], cur = diff[j];
            // previous was below (<=0) and current above (>0) => EMA70 crossed ABOVE EMA200 => BULL
            if (prev <= 0 && cur > 0) { crossType = 'BULL'; crossIndexFromEnd = diff.length - 1 - j; break; }
            // previous was above (>=0) and current below (<0) => EMA70 crossed BELOW EMA200 => BEAR
            if (prev >= 0 && cur < 0) { crossType = 'BEAR'; crossIndexFromEnd = diff.length - 1 - j; break; }
          }

          const lastIdx = closes.length - 1;
          return {
            ok: true,
            ema70Series: ema70,
            ema200Series: ema200,
            crossType,
            crossIndexFromEnd,
            lastClose: closes[lastIdx],
            lastHigh: klines[lastIdx].h,
            lastLow: klines[lastIdx].l,
            closes,
            highs: klines.map(k=>k.h),
            lows: klines.map(k=>k.l)
          };
        }

        async function fetchKlines(symbol, interval=INTERVAL, limit=LOOKBACK_EMA200) {
          const params = { symbol, interval, limit };
          const data = await safeFetch(KLINES, params);
          return data.map(k => ({ t:k[0], o:parseFloat(k[1]), h:parseFloat(k[2]), l:parseFloat(k[3]), c:parseFloat(k[4]), v:parseFloat(k[5]) }));
        }

        /* Build trade setup (same as your logic) */
        function buildTradeSetupByCross(sym, chk, klines, priceChangePercent = 0){
          if (!chk || !chk.ok || !chk.crossType) return null;
          const atr = computeATR(klines.slice(-40), 14) || computeATR(klines, 14) || 0;
          const stopAtrMult = Math.max(0.1, Number(document.getElementById('stopAtrMult')?.value || 0.8));
          const tp1AtrMult = Math.max(0.1, Number(document.getElementById('tp1AtrMult')?.value || 1.5));
          const tp2AtrMult = Math.max(0.1, Number(document.getElementById('tp2AtrMult')?.value || 3.0));
          const lastClose = chk.lastClose;
          const lastLow = chk.lastLow;
          const lastHigh = chk.lastHigh;
          let prec = 4;
          if (lastClose >= 100) prec = 2; else if (lastClose >= 10) prec = 3; else if (lastClose < 1) prec = 6;
          const direction = chk.crossType === 'BULL' ? 'LONG' : 'SHORT';
          const entry = lastClose;
          let stop;
          if (direction === 'LONG') {
            const ema200Latest = chk.ema200Series ? chk.ema200Series[chk.ema200Series.length -1] : null;
            stop = Math.min(lastLow - atr * stopAtrMult, (ema200Latest ? ema200Latest - atr * 0.25 : lastLow - atr*stopAtrMult));
            if (stop >= entry) stop = entry - Math.max(atr * 0.2, (entry * 0.0005));
          } else {
            const ema200Latest = chk.ema200Series ? chk.ema200Series[chk.ema200Series.length -1] : null;
            stop = Math.max(lastHigh + atr * stopAtrMult, (ema200Latest ? ema200Latest + atr * 0.25 : lastHigh + atr*stopAtrMult));
            if (stop <= entry) stop = entry + Math.max(atr * 0.2, (entry * 0.0005));
          }
          let tp1,tp2;
          if (direction === 'LONG') { tp1 = entry + atr * tp1AtrMult; tp2 = entry + atr * tp2AtrMult; }
          else { tp1 = entry - atr * tp1AtrMult; tp2 = entry - atr * tp2AtrMult; }
          const risk = Math.abs(entry - stop);
          const rr1 = risk > 0 ? Math.abs(tp1 - entry) / risk : 0;
          const rr2 = risk > 0 ? Math.abs(tp2 - entry) / risk : 0;
          return { symbol: sym, direction, entry, stop, tp1, tp2, rr1, rr2, atr, prec, priceChangePercent };
        }

        async function batchAnalyzeCross(symbols, batchSize=5, batchDelay=1200) {
          const results = [];
          const crossWindow = Math.max(1, Number(document.getElementById('crossWindow')?.value || 3));
          for (let i=0;i<symbols.length;i+=batchSize) {
            const batch = symbols.slice(i, i+batchSize);
            setStatus(`analyzing batch ${Math.floor(i/batchSize)+1}/${Math.ceil(symbols.length/batchSize)}`, true);
            const promises = batch.map(async sym => {
              try {
                const kl = await fetchKlines(sym, INTERVAL, LOOKBACK_EMA200);
                const chk = checkEMACross(kl, crossWindow);
                return { sym, chk, kl };
              } catch (e) {
                return { sym, error: e.message || String(e) };
              }
            });
            const resolved = await Promise.all(promises);
            results.push(...resolved);
            if (i + batchSize < symbols.length) {
              await new Promise(r => setTimeout(r, batchDelay));
            }
          }
          setStatus('EMA cross analysis complete', false);
          return results;
        }

        function ensureAudioContext(){
          if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().then(()=> audioUnlocked = true).catch(()=> audioUnlocked=false);
          else audioUnlocked = true;
        }
        function playBeep(freq=880, duration=120, volume=0.12, type='sine'){ if (!soundToggle.checked) return; if (!audioCtx) try{ ensureAudioContext(); }catch(e){return;} if(!audioUnlocked) return; try{ const now = audioCtx.currentTime; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type=type; o.frequency.setValueAtTime(freq, now); g.gain.setValueAtTime(volume, now); g.gain.linearRampToValueAtTime(0.0001, now + duration/1000); o.connect(g); g.connect(audioCtx.destination); o.start(now); o.stop(now + duration/1000 + 0.02);}catch(e){}
        function playNotification(){ if (!soundToggle.checked) return; playBeep(1046,80,0.08); setTimeout(()=>playBeep(1318,70,0.07),120); }

        async function handleCrossResultsAndPlaySound(results){
          const detected = [];
          // we need priceChangePercent for sorting by 24h change later; pull from latestTickers map
          const priceMap = {};
          latestTickers.forEach(t=> priceMap[t.symbol] = t.priceChangePercent);

          results.forEach(r=>{
            const id = 'cross-' + r.sym;
            const cell = document.getElementById(id);
            if (cell) {
              if (r.chk && r.chk.ok && r.chk.crossType) {
                const txt = r.chk.crossType === 'BULL' ? '70‚Üí200 (bull)' : '70‚Üí200 (bear)';
                cell.textContent = txt;
                cell.classList.remove('green','red');
                cell.classList.add(r.chk.crossType === 'BULL' ? 'green' : 'red');
              } else {
                cell.textContent = '‚Äî';
                cell.classList.remove('green','red');
              }
            }
            if (r.chk && r.chk.ok && r.chk.crossType) {
              const setup = buildTradeSetupByCross(r.sym, r.chk, r.kl || [], priceMap[r.sym] || 0);
              if (setup) {
                detected.push({
                  symbol: r.sym,
                  crossType: r.chk.crossType,
                  crossIndexFromEnd: r.chk.crossIndexFromEnd,
                  closePct: Math.abs(r.chk.lastClose - (r.chk.ema200Series ? r.chk.ema200Series[r.chk.ema200Series.length-1] : r.chk.lastClose))/ (r.chk.ema200Series ? r.chk.ema200Series[r.chk.ema200Series.length-1] : r.chk.lastClose) * 100,
                  priceChangePercent: priceMap[r.sym] || 0,
                  ...setup
                });
              }
            }
          });

          if (soundToggle.checked && detected.length > 0) {
            playNotification();
            let delay=360;
            detected.slice(0,10).forEach(d=>{
              setTimeout(()=>{ if (d.crossType==='BULL') playBeep(1400,90,0.09); else playBeep(900,120,0.11); }, delay);
              delay+=140;
            });
          }

          // sort: most recent cross (smaller crossIndexFromEnd) first, then R:R1 desc
          detected.sort((a,b)=>{
            const ai = (a.crossIndexFromEnd == null) ? 9999 : a.crossIndexFromEnd;
            const bi = (b.crossIndexFromEnd == null) ? 9999 : b.crossIndexFromEnd;
            if (ai !== bi) return ai - bi;
            if ((b.rr1 || 0) !== (a.rr1 || 0)) return (b.rr1 || 0) - (a.rr1 || 0);
            return Math.abs(b.closePct || 0) - Math.abs(a.closePct || 0);
          });

          // If you want to sort by 24h price change instead, replace the previous sort with:
          // detected.sort((a,b)=> (b.priceChangePercent||0) - (a.priceChangePercent||0));

          renderTop(detected.slice(0,50));
          setStatus(`EMA cross analysis finished. ${detected.length} symbols with cross setups`, false);
          lastResults = results;
        }

        async function pollTickersOnce({ doAnalyze = false } = {}) {
          try {
            setStatus('polling tickers...', true);
            const raw = await safeFetch(TICKER_24H, null, 15000);
            const filtered = filterTickers(raw);
            filtered.sort((a,b)=> (b.quoteVolume || 0) - (a.quoteVolume || 0));
            latestTickers = filtered;
            renderPairs(filtered.slice(0,500));
            setStatus(`polled ${raw.length} tickers ‚Äî ${filtered.length} USDT perpetuals (blacklist removed)`, false);
            setLastUpdated();
            lastResults = [];

            if ((doAnalyze || autoAnalyzeToggle.checked) && latestTickers.length) {
              ensureAudioContext();
              const maxAnalyze = Math.max(1, Number(maxAnalyzeInput.value) || 20);
              const batchSize = Math.max(1, Number(batchSizeInput.value) || 5);
              const batchDelay = Math.max(300, Number(batchDelayInput.value) || 1200);
              const toAnalyze = latestTickers.slice(0, maxAnalyze).map(t => t.symbol);
              setStatus(`starting EMA cross analysis for ${toAnalyze.length} symbols...`, true);
              const results = await batchAnalyzeCross(toAnalyze, batchSize, batchDelay);
              await handleCrossResultsAndPlaySound(results);
            }
          } catch (e) {
            console.error(e);
            setStatus('poll error: ' + (e.message || e), false);
          }
        }

        // --- UI behavior (start/stop/analyze) ---
        startBtn.onclick = ()=>{
          const interval = Math.max(5, Number(pollIntervalInput.value) || 10);
          if (pollTimer) clearInterval(pollTimer);
          ensureAudioContext();
          pollTickersOnce({ doAnalyze: false });
          pollTimer = setInterval(()=>{ if(!isPaused) pollTickersOnce({ doAnalyze: false }); }, interval * 1000);
          startBtn.disabled = true; pauseBtn.disabled = false;
          setStatus('polling started', true);
        };

        pauseBtn.onclick = ()=>{
          isPaused = !isPaused;
          pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
          pauseBtn.classList.toggle('warn', isPaused);
          setStatus(isPaused ? 'polling paused' : (pollTimer ? 'polling resumed' : 'not polling'), !isPaused);
        };

        refreshBtn.onclick = ()=> {
          setStatus('manual refresh...', true);
          pollTickersOnce({ doAnalyze: false }).then(()=> setStatus('manual refresh done', false));
        };

        analyzeBtn.onclick = async ()=>{
          if (!latestTickers || latestTickers.length === 0) { setStatus('no symbols to analyze - run poll first', false); return; }
          ensureAudioContext();
          const maxAnalyze = Math.max(1, Number(maxAnalyzeInput.value) || 20);
          const batchSize = Math.max(1, Number(batchSizeInput.value) || 5);
          const batchDelay = Math.max(300, Number(batchDelayInput.value) || 1200);
          const toAnalyze = latestTickers.slice(0, maxAnalyze).map(t => t.symbol);
          setStatus(`starting EMA cross analysis for ${toAnalyze.length} symbols (batch ${batchSize}, delay ${batchDelay}ms).`, true);
          const results = await batchAnalyzeCross(toAnalyze, batchSize, batchDelay);
          await handleCrossResultsAndPlaySound(results);
        };

        // Search/filter UI
        function applySearchAndFilter(){
          const q = (searchBox.value || '').trim().toLowerCase();
          const filter = crossFilter.value;
          const sortVal = sortBy.value;
          let items = latestTickers.slice();

          const crossMap = {};
          (lastResults || []).forEach(r => { if(r && r.sym && r.chk && r.chk.ok && r.chk.crossType) crossMap[r.sym] = r.chk.crossType; });

          if (filter === 'BULL') items = items.filter(i => crossMap[i.symbol] === 'BULL');
          else if (filter === 'BEAR') items = items.filter(i => crossMap[i.symbol] === 'BEAR');
          else if (filter === 'NO_CROSS') items = items.filter(i => !crossMap[i.symbol]);

          if (q) items = items.filter(i => i.symbol.toLowerCase().includes(q));

          switch(sortVal){
            case 'volume_desc': items.sort((a,b)=> (b.quoteVolume||0) - (a.quoteVolume||0)); break;
            case 'volume_asc': items.sort((a,b)=> (a.quoteVolume||0) - (b.quoteVolume||0)); break;
            case 'change_desc': items.sort((a,b)=> (b.priceChangePercent||0) - (a.priceChangePercent||0)); break;
            case 'change_asc': items.sort((a,b)=> (a.priceChangePercent||0) - (b.priceChangePercent||0)); break;
            case 'symbol_asc': items.sort((a,b)=> a.symbol.localeCompare(b.symbol)); break;
          }

          renderPairs(items.slice(0,500));

          if (lastResults && lastResults.length) {
            lastResults.forEach(r=>{
              const id = 'cross-' + r.sym;
              const cell = document.getElementById(id);
              if (cell && r.chk && r.chk.ok && r.chk.crossType) {
                cell.textContent = r.chk.crossType === 'BULL' ? '70‚Üí200 (bull)' : '70‚Üí200 (bear)';
                cell.classList.add(r.chk.crossType === 'BULL' ? 'green' : 'red');
              }
            });
          }
        }
        const debounce = (fn, wait=200)=>{ let t; return function(...a){ clearTimeout(t); t=setTimeout(()=>fn.apply(this,a), wait); } };
        searchBox.addEventListener('input', debounce(applySearchAndFilter,180));
        crossFilter.addEventListener('change', applySearchAndFilter);
        sortBy.addEventListener('change', applySearchAndFilter);

        // header-click quick sort
        document.querySelectorAll('#pairsTable thead th').forEach(th=>{
          th.style.cursor = 'pointer';
          th.addEventListener('click', ()=>{
            const col = th.getAttribute('data-col');
            if (!col) return;
            if (col === 'vol') sortBy.value = 'volume_desc';
            else if (col === 'change') sortBy.value = 'change_desc';
            else if (col === 'symbol') sortBy.value = 'symbol_asc';
            applySearchAndFilter();
          });
        });

        // persist settings (basic)
        function saveSettings(){
          localStorage.setItem('scanner.settings', JSON.stringify({
            pollInterval: pollIntervalInput.value,
            maxAnalyze: maxAnalyzeInput.value,
            batchSize: batchSizeInput.value,
            batchDelay: batchDelayInput.value,
            autoAnalyze: autoAnalyzeToggle.checked,
            sound: soundToggle.checked
          }));
        }
        function loadSettings(){
          try {
            const s = JSON.parse(localStorage.getItem('scanner.settings') || '{}');
            if(s.pollInterval) pollIntervalInput.value = s.pollInterval;
            if(s.maxAnalyze) maxAnalyzeInput.value = s.maxAnalyze;
            if(s.batchSize) batchSizeInput.value = s.batchSize;
            if(s.batchDelay) batchDelayInput.value = s.batchDelay;
            if(typeof s.autoAnalyze === 'boolean') autoAnalyzeToggle.checked = s.autoAnalyze;
            if(typeof s.sound === 'boolean') soundToggle.checked = s.sound;
          } catch(e){}
        }
        [pollIntervalInput, maxAnalyzeInput, batchSizeInput, batchDelayInput, autoAnalyzeToggle, soundToggle].forEach(el=>el.addEventListener('change', saveSettings));
        loadSettings();

        // initial status
        setStatus('idle ‚Äî click "Start" or "Refresh" to load tickers', false);

        /* =====================
           Leverage Calculator
           ===================== */
        (function leverageCalculatorInit(){
          let capital = parseFloat(capitalInput.value) || 0;
          let leverage = parseFloat(leverageInput.value) || 1;
          let moves = [4,7,10];

          function positionSize(){ return capital * leverage; }
          function liquidationThreshold(){ return 100 / leverage; }
          function calcPL(percent){ return (percent / 100) * positionSize(); }
          function formatMoney(n){ return Number(n).toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2}); }

          function renderList(){
            listEl.innerHTML = '';
            const sorted = Array.from(new Set(moves)).sort((a,b)=>a-b);
            sorted.forEach(p=>{
              const isLiquidation = (Math.abs(p) >= liquidationThreshold());
              const item = document.createElement('div'); item.className='calc-item';
              const left = document.createElement('div'); left.style.display='flex'; left.style.flexDirection='column'; left.style.gap='6px';
              left.innerHTML = `<div>üìà ${p}% Gain ‚Üí <span style="color:#6ee7b7;font-weight:700;">+ $${formatMoney(calcPL(p))}</span></div>
                                <div>üìâ ${p}% Loss ‚Üí <span class="${isLiquidation? 'danger':''}">- $${formatMoney(calcPL(-p))}</span></div>`;
              const right = document.createElement('div'); right.style.display='flex'; right.style.flexDirection='column'; right.style.alignItems='flex-end';
              const removeBtn = document.createElement('button'); removeBtn.className='secondary'; removeBtn.style.padding='6px 8px'; removeBtn.textContent='‚úñ';
              removeBtn.onclick = ()=>{ moves = moves.filter(x=>x!==p); renderList(); };
              right.appendChild(removeBtn);
              if (isLiquidation){ const w=document.createElement('div'); w.style.color='#ff9b9b'; w.style.fontSize='12px'; w.style.fontWeight='700'; w.textContent='‚ö†Ô∏è Risk of Liquidation'; right.appendChild(w); }
              item.appendChild(left); item.appendChild(right); listEl.appendChild(item);
            });
            liqText.textContent = liquidationThreshold().toFixed(2) + '%';
            liqLeverage.textContent = leverage;
          }

          renderList();

          addBtn.addEventListener('click', ()=>{
            const val = parseFloat(percentInput.value);
            if (!isNaN(val)) { moves = Array.from(new Set([...moves, val])); percentInput.value=''; renderList(); }
          });
          percentInput.addEventListener('keydown',(e)=>{ if(e.key==='Enter') addBtn.click(); });

          capitalInput.addEventListener('input', ()=>{ const v=parseFloat(capitalInput.value); capital = isFinite(v)? v : 0; renderList(); });
          leverageInput.addEventListener('input', ()=>{ const v=parseFloat(leverageInput.value); leverage = isFinite(v) && v>0 ? v : 1; renderList(); });

          // helpful: expose state
          window.__leverageCalc = { getState: ()=> ({ capital, leverage, moves, pos: positionSize(), liq: liquidationThreshold() }) };
        })();

        // little UX: apply filters if we already have tickers
        window.addEventListener('load', ()=>{ setTimeout(()=> applySearchAndFilter(), 300); });

      }); // DOMContentLoaded
    } // guard
  </script>
</body>
</html>
