<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Binance Futures USDT — Live Filter + Consolidation Scanner</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Inter, Roboto, Arial; background:#0f1720; color:#e6eef8; margin:16px; }
    h1 { margin:0 0 8px 0; font-size:18px; }
    .controls { display:flex; gap:8px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
    button { padding:8px 12px; border:0; background:#0ea5a4; color:#042024; border-radius:6px; cursor:pointer; }
    button.secondary { background:#334155; color:#e6eef8; }
    input, select { padding:6px 8px; border-radius:6px; border:1px solid #334155; background:#0b1220; color:#e6eef8; }
    table { width:100%; border-collapse:collapse; margin-top:8px; }
    th, td { padding:8px 6px; font-size:13px; border-bottom:1px solid rgba(255,255,255,0.04); text-align:left; }
    th { color:#9fb3c8; font-weight:600; font-size:12px; text-transform:uppercase; }
    .green { color:#5eead4; } .red { color:#fb7185; }
    .muted { color:#94a3b8; font-size:12px; }
    .status { margin-left:8px; font-size:13px; color:#94a3b8; }
    .small { font-size:12px; color:#a7b8c8; }
    .chip { padding:4px 8px; border-radius:999px; background:#091826; border:1px solid #153241; }
  </style>
</head>
<body>
  <h1>Binance Futures (Perp USDT) — Live Filter & Consolidation Scanner</h1>
  <div class="controls">
    <button id="startPoll">Start Live Polling</button>
    <button id="stopPoll" class="secondary" disabled>Stop Polling</button>

    <label class="chip">
      Poll interval (s):
      <input id="pollInterval" type="number" min="5" value="10" style="width:72px; margin-left:6px;">
    </label>

    <label class="chip">
      Max symbols to analyze:
      <input id="maxAnalyze" type="number" min="1" value="20" style="width:72px; margin-left:6px;">
    </label>

    <label class="chip">
      Batch size:
      <input id="batchSize" type="number" min="1" value="5" style="width:60px; margin-left:6px;">
    </label>

    <label class="chip">
      Batch delay (ms):
      <input id="batchDelay" type="number" min="300" value="1200" style="width:80px; margin-left:6px;">
    </label>

    <button id="analyze" class="secondary">Analyze Consolidation (safe batch)</button>

    <div class="status" id="status">idle</div>
  </div>

  <div style="display:flex; gap:12px; align-items:flex-start;">
    <div style="flex:1; min-width:420px;">
      <div class="muted">Filtered pairs (24h change windows): <span class="small">Green 0→+15% | Red 0→-15%</span></div>
      <table id="pairsTable">
        <thead>
          <tr>
            <th>Symbol</th>
            <th>Last</th>
            <th>24h %</th>
            <th>QuoteVol</th>
            <th>Category</th>
            <th>Consol. (score)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div style="width:360px;">
      <div class="muted">Top candidates (consolidating)</div>
      <table id="topTable">
        <thead>
          <tr><th>Symbol</th><th>Class</th><th>Score</th><th>range%</th><th>emaDev%</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script>
  // ---------- Configurable constants ----------
  const TICKER_24H = 'https://fapi.binance.com/fapi/v1/ticker/24hr';
  const KLINES = 'https://fapi.binance.com/fapi/v1/klines';
  const INTERVAL = '15m';
  const LOOKBACK = 48; // number of candles (48 * 15m = 12 hours)
  const EMA_PERIODS = [14,21,70];
  const RANGE_PCT_THRESHOLD = 3.0;      // default detection thresholds (tweakable in script)
  const EMA_COMPRESSION_PCT = 0.5;
  const VOLUME_DROP_PCT = 0.85;
  const ATR_PCT_THRESHOLD = 0.8;
  // ------------------------------------------------

  // UI elements
  const startBtn = document.getElementById('startPoll');
  const stopBtn = document.getElementById('stopPoll');
  const pollIntervalInput = document.getElementById('pollInterval');
  const maxAnalyzeInput = document.getElementById('maxAnalyze');
  const batchSizeInput = document.getElementById('batchSize');
  const batchDelayInput = document.getElementById('batchDelay');
  const analyzeBtn = document.getElementById('analyze');
  const statusEl = document.getElementById('status');
  const pairsTbody = document.querySelector('#pairsTable tbody');
  const topTbody = document.querySelector('#topTable tbody');

  let pollTimer = null;
  let latestTickers = []; // cached tickers that match filters

  function setStatus(s) { statusEl.textContent = s; }

  // helper fetch wrapper with error handling
  async function safeFetch(url, params = null) {
    const p = params ? '?' + new URLSearchParams(params).toString() : '';
    const res = await fetch(url + p);
    if (!res.ok) {
      throw new Error('HTTP ' + res.status + ' ' + res.statusText);
    }
    return res.json();
  }

// Your blacklist
const blacklist = [
  "ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT","AGIXUSDT","LINAUSDT",
  "LOKAUSDT","KEYUSDT","MDTUSDT","LOOMUSDT","RENUSDT","OMNIUSDT","SLERFUSDT",
  "STMXUSDT","UXLINKUSDT","BSWUSDT","NEIROETHUSDT","VIDTUSDT","TROYUSDT",
  "BAKEUSDT","AMBUSDT","MEMEFIUSDT","NULSUSDT","HIFIUSDT","LEVERUSDT","XEMUSDT",
  "STRAXUSDT","COMBOUSDT","AI16ZUSDT"
];

// Apply 24h change filters + USDT perp only + blacklist filter
function filterTickers(allTickers) {
  return allTickers
    .filter(t =>
      t.symbol &&
      t.symbol.endsWith('USDT') &&
      !blacklist.includes(t.symbol) // ✨ blacklist filter added
    )
    .map(t => ({
      symbol: t.symbol,
      lastPrice: Number(t.lastPrice),
      priceChangePercent: Number(t.priceChangePercent),
      quoteVolume: Number(t.quoteVolume)
    }))
    .filter(t => {
      const c = t.priceChangePercent;
      return (c > 0 && c <= 15) || (c < 0 && c >= -15);
    })
    .sort((a, b) => Math.abs(b.priceChangePercent) - Math.abs(a.priceChangePercent));
}

  // Render table
  function renderPairs(list) {
    pairsTbody.innerHTML = '';
    list.forEach(item => {
      const tr = document.createElement('tr');
      const cls = item.priceChangePercent > 0 ? 'green' : 'red';
      tr.innerHTML = `
        <td><strong>${item.symbol}</strong></td>
        <td>${item.lastPrice.toLocaleString(undefined,{maximumFractionDigits:8})}</td>
        <td class="${cls}">${item.priceChangePercent.toFixed(2)}%</td>
        <td class="small">${Number(item.quoteVolume).toLocaleString(undefined,{maximumFractionDigits:0})}</td>
        <td class="small">${item.priceChangePercent > 0 ? 'Bullish' : 'Bearish'}</td>
        <td class="small" id="consol-${item.symbol}">—</td>
      `;
      pairsTbody.appendChild(tr);
    });
  }

  function renderTop(results) {
    topTbody.innerHTML = '';
    results.forEach(r => {
      const tr = document.createElement('tr');
      const cls = r.classification === 'consolidating' ? 'green' : (r.classification === 'possible-consolidation' ? '' : 'small');
      tr.innerHTML = `
        <td><strong>${r.symbol}</strong></td>
        <td class="${cls}">${r.classification}</td>
        <td>${r.score}</td>
        <td>${Number(r.rangePct).toFixed(3)}</td>
        <td>${Number(r.emaMaxDev).toFixed(3)}</td>
      `;
      topTbody.appendChild(tr);
    });
  }

  // EMA calculation (returns last EMA value)
  function ema(values, period) {
    if (values.length < period) return null;
    const k = 2 / (period + 1);
    let prev = values.slice(0, period).reduce((a,b)=>a+b,0)/period;
    for (let i = period; i < values.length; i++) {
      prev = values[i]*k + prev*(1-k);
    }
    return prev;
  }

  // ATR computation
  function computeATR(klines, period = 14) {
    if (klines.length < period + 1) return null;
    const trs = [];
    for (let i=1;i<klines.length;i++) {
      const hi = klines[i].h, lo = klines[i].l, prevC = klines[i-1].c;
      const tr = Math.max(hi - lo, Math.abs(hi - prevC), Math.abs(lo - prevC));
      trs.push(tr);
    }
    const slice = trs.slice(-period);
    const atr = slice.reduce((a,b)=>a+b,0)/slice.length;
    return atr;
  }

  // Analyze consolidation (same rules as server scanner)
  function analyzeConsolidation(klines) {
    if (!klines || klines.length < 8) return { ok: false };

    const closes = klines.map(k=>k.c);
    const highs = klines.map(k=>k.h);
    const lows  = klines.map(k=>k.l);
    const vols  = klines.map(k=>k.v);

    const maxH = Math.max(...highs);
    const minL = Math.min(...lows);
    const avgPrice = closes.reduce((a,b)=>a+b,0)/closes.length;
    const rangePct = (maxH - minL) / avgPrice * 100;

    const emaVals = {};
    EMA_PERIODS.forEach(p => emaVals[p] = ema(closes, p));
    const emaDevs = Object.values(emaVals).filter(v=>v).map(v => Math.abs(v - avgPrice) / avgPrice * 100);
    const emaMaxDev = emaDevs.length ? Math.max(...emaDevs) : 999;

    const half = Math.floor(vols.length / 2);
    const firstAvgVol = vols.slice(0, half).reduce((a,b)=>a+b,0)/Math.max(1, half);
    const secondAvgVol = vols.slice(half).reduce((a,b)=>a+b,0)/Math.max(1, vols.length-half);

    const mid = Math.floor(klines.length/2);
    const atrOld = computeATR(klines.slice(0, mid+1), Math.min(14, Math.max(3, Math.floor((mid+1)/4))));
    const atrRecent = computeATR(klines.slice(mid), Math.min(14, Math.max(3, Math.floor((klines.length-mid)/4))));

    const isTightRange = rangePct <= RANGE_PCT_THRESHOLD;
    const isEMACompressed = emaMaxDev <= EMA_COMPRESSION_PCT;
    const isVolumeDropped = secondAvgVol <= firstAvgVol * VOLUME_DROP_PCT;
    const isATRlower = (atrRecent && atrOld) ? (atrRecent <= atrOld * ATR_PCT_THRESHOLD) : false;

    let score = 0;
    if (isTightRange) score += 1;
    if (isEMACompressed) score += 1;
    if (isVolumeDropped) score += 1;
    if (isATRlower) score += 1;

    const classification = score >= 3 ? 'consolidating' :
                           score === 2 ? 'possible-consolidation' :
                           'not-consolidating';

    return {
      ok: true,
      rangePct,
      emaMaxDev,
      firstAvgVol,
      secondAvgVol,
      atrOld,
      atrRecent,
      score,
      classification
    };
  }

  // fetch klines and normalize to objects
  async function fetchKlines(symbol, interval=INTERVAL, limit=LOOKBACK) {
    const params = { symbol, interval, limit };
    const data = await safeFetch(KLINES, params);
    return data.map(k => ({
      t: k[0],
      o: parseFloat(k[1]),
      h: parseFloat(k[2]),
      l: parseFloat(k[3]),
      c: parseFloat(k[4]),
      v: parseFloat(k[5])
    }));
  }

  // Batch analyze with safety controls to avoid too many concurrent requests
  async function batchAnalyze(symbols, batchSize=5, batchDelay=1200) {
    const results = [];
    for (let i=0;i<symbols.length;i+=batchSize) {
      const batch = symbols.slice(i, i+batchSize);
      setStatus(`analyzing batch ${Math.floor(i/batchSize)+1} / ${Math.ceil(symbols.length/batchSize)}`);
      const promises = batch.map(async sym => {
        try {
          const kl = await fetchKlines(sym);
          const analysis = analyzeConsolidation(kl);
          return { sym, analysis };
        } catch (e) {
          return { sym, error: e.message || String(e) };
        }
      });
      const resolved = await Promise.all(promises);
      results.push(...resolved);
      if (i + batchSize < symbols.length) {
        await new Promise(r => setTimeout(r, batchDelay));
      }
    }
    setStatus('analysis complete');
    return results;
  }

  // Main polling loop (single request per poll)
  async function pollTickersOnce() {
    try {
      const raw = await safeFetch(TICKER_24H);
      const filtered = filterTickers(raw);
      latestTickers = filtered;
      renderPairs(filtered.slice(0, 500)); // limit table to first 500 entries for UI responsiveness
      setStatus(`polled ${raw.length} tickers, ${filtered.length} matched filters`);
    } catch (e) {
      setStatus('poll error: ' + e.message);
      console.error(e);
    }
  }

  // Event handlers
  startBtn.onclick = () => {
    const interval = Math.max(5, Number(pollIntervalInput.value) || 10);
    if (pollTimer) clearInterval(pollTimer);
    pollTickersOnce(); // immediate
    pollTimer = setInterval(pollTickersOnce, interval * 1000);
    startBtn.disabled = true;
    stopBtn.disabled = false;
    setStatus('polling started');
  };

  stopBtn.onclick = () => {
    if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
    startBtn.disabled = false;
    stopBtn.disabled = true;
    setStatus('polling stopped');
  };

  analyzeBtn.onclick = async () => {
    if (!latestTickers || latestTickers.length === 0) {
      setStatus('no symbols to analyze - run poll first');
      return;
    }
    const maxAnalyze = Math.max(1, Number(maxAnalyzeInput.value) || 20);
    const batchSize = Math.max(1, Number(batchSizeInput.value) || 5);
    const batchDelay = Math.max(300, Number(batchDelayInput.value) || 1200);

    const toAnalyze = latestTickers.slice(0, maxAnalyze).map(t => t.symbol);
    setStatus(`starting analysis for ${toAnalyze.length} symbols (batch ${batchSize}, delay ${batchDelay}ms)`);

    const results = await batchAnalyze(toAnalyze, batchSize, batchDelay);

    // update UI cells and collect consolidating candidates
    const consolidated = [];
    results.forEach(r => {
      const id = 'consol-' + r.sym;
      const cell = document.getElementById(id);
      if (cell) {
        if (r.analysis && r.analysis.ok) {
          cell.textContent = `${r.analysis.classification} (${r.analysis.score})`;
        } else {
          cell.textContent = 'err';
        }
      }
      if (r.analysis && r.analysis.ok && r.analysis.classification === 'consolidating') {
        consolidated.push({
          symbol: r.sym,
          classification: r.analysis.classification,
          score: r.analysis.score,
          rangePct: r.analysis.rangePct,
          emaMaxDev: r.analysis.emaMaxDev
        });
      }
    });

    // sort and show in top table
    consolidated.sort((a,b) => b.score - a.score || a.rangePct - b.rangePct);
    renderTop(consolidated.slice(0,50));
    setStatus(`analysis finished. ${consolidated.length} consolidating found`);
  };

  // initial simple UI state
  setStatus('idle — click "Start Live Polling"');

  // optionally auto-start polling (comment out if not desired)
  // startBtn.click();
  </script>
</body>
</html>
